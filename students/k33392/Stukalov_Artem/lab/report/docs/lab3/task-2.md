# Пасинг веб страниц

Сравнение перфоманса парсинга веб страниц при использовании разных подходов: threads, porcess и async.  
Дабы не писать разные парсеры возьмем за основу один сайт буккросинга книг и попробуем спарсить 20 ссылок на книги. 20 - кол-во реальных cpu моего процессора.

Ниже приведен листинг кода, который использовался для тестирования определенного подхода. Замеры проводились при помощи утилиты `time`, замерялись `real`, `user` и `sys` время.

=== "Base"

    ```Python title="base.py"
    --8<-- "lab-3/task-2/src/base.py"
    ```

=== "DB"

    ```Python title="db.py"
    --8<-- "lab-3/task-2/src/db.py"
    ```

=== "Threaded"

    ```Python title="threaded.py"
    --8<-- "lab-3/task-2/src/threaded.py"
    ```

=== "Multiprocess"

    ```Python title="multiprocess.py"
    --8<-- "lab-3/task-2/src/multiprocess.py"
    ```

=== "Async"

    ```Python title="async.py"
    --8<-- "lab-3/task-2/src/async.py"
    ```

## Результаты замеров

```
runners/threaded.py urls = 20
real    0m2.288s
user    0m2.175s
sys     0m0.202s
------------------------------

runners/multiprocess.py urls = 20
real    0m2.340s
user    0m1.670s
sys     0m0.614s
------------------------------

runners/async.py urls = 20
real    0m2.376s
user    0m1.144s
sys     0m0.128s
------------------------------
```

## Выводы

Как можем видеть различия при замерах получились назначительные. Более интересно тут посмотреть на `user` время. По разнице с `real` временем в варианте с `async` можно заметить, что такой вариант меньше задействует ресурсы и позволяет системе работать более эффективно. Так что такой подход является более предпочтительным несмотря на разницу в 100мс.
