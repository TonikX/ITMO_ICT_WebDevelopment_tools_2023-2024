# Производительность различных методов параллелизма для CPU-bound задач

## Описание методов

- **`async`**:
    - Использует кооперативную многозадачность, подходит для I/O-bound задач, но менее эффективен
      для CPU-bound задач из-за ограничений GIL (Global Interpreter Lock).

- **`multiprocessing`**:
    - Создает отдельные процессы для выполнения задач, что позволяет обойти GIL и использовать
      несколько ядер процессора. Идеален для CPU-bound задач.

- **`threading`**:
    - Позволяет создавать несколько потоков в одном процессе. Подходит для I/O-bound задач, но
      ограничен GIL для CPU-bound задач.

## Результаты тестирования

| Размер задачи | Async (секунды) | Multiprocessing (секунды) | Threading (секунды) |
|---------------|-----------------|---------------------------|---------------------|
| 1,000,000     | 0.001           | 0.148                     | 0.003               |
| 1,000,000     | 0.029           | 0.152                     | 0.026               |
| 10,000,000    | 0.382           | 0.215                     | 0.274               |
| 100,000,000   | 3.130           | 0.842                     | 2.977               |

## Выводы

1. **Для небольших задач**:
    - `async` показывает наилучшую производительность (0.001 секунды), так как накладные расходы на
      переключение контекста минимальны.
    - `threading` также эффективен (0.003 секунды), но немного медленнее.
    - `multiprocessing` значительно медленнее (0.148 секунды) из-за накладных расходов на создание
      процессов.

2. **Для задач среднего размера**:
    - `async` и `threading` показывают сопоставимые результаты (0.029 и 0.026 секунды
      соответственно).
    - `multiprocessing` остается медленнее (0.152 секунды), но разница становится менее заметной.

3. **Для крупных задач**:
    - `multiprocessing` начинает демонстрировать свои преимущества (0.215 секунды),
      обгоняя `async` (0.382 секунды) и `threading` (0.274 секунды).
    - `async` становится менее эффективным из-за отсутствия параллелизма.

4. **Для очень крупных задач**:
    - `multiprocessing` значительно обгоняет другие методы (0.842 секунды), эффективно используя
      параллелизм.
    - `async` и `threading` становятся значительно медленнее (3.130 и 2.977 секунды соответственно)
      из-за ограничений GIL и отсутствия параллелизма.

## Заключение

- **Асинхронное программирование**:
    - Эффективно для небольших I/O-bound задач, но не подходит для крупных CPU-bound задач.

- **Многопроцессорность**:
    - Лучший выбор для крупных CPU-bound задач благодаря возможности использования нескольких ядер
      процессора и обхода GIL.

- **Многопоточность**:
    - Хорошо подходит для I/O-bound задач, но ограничена GIL для CPU-bound задач. Показывает
      приемлемую производительность для небольших и средних задач, но уступает `multiprocessing` для
      крупных задач.
