
# Установка и запуск приложения

Когда я начала работу с FastAPI, первым делом я убедилась, что он не требует длительной установки и настройки приложения. Для запуска приложения мне достаточно выполнить несколько простых операций:

1. **Установка зависимостей**: В моем виртуальном окружении я установила FastAPI и все сопутствующие библиотеки, выполнив команду:

```

pip install fastapi[all]

```

2. **Создание основного файла**: Я создала файл `main.py`, в котором инициализировала экземпляр класса `FastAPI` и добавила простой эндпоинт для тестирования.

```python
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def hello():
    return "Hello, [username]!"
   ```

Запуск сервера: Для запуска приложения я воспользовалась веб-сервером uvicorn, который поддерживает FastAPI. Я использовала команду:
```
uvicorn main:app --reload
```
Это позволяет мне автоматически перезапускать сервер при изменениях в коде.
Результат
После запуска приложения по адресу http://127.0.0.1:8000 я видела приветственное сообщение, которое я задала в функции hello().

Чтобы получить доступ к автоматически сгенерированной документации к моему API, я перешла по адресу http://127.0.0.1:8000/docs.
## Методы и виртуальная БД

### Создание тестовой БД

Для демонстрации возможностей API внутри FastAPI, мне потребовалось создать временную базу данных. В качестве примера, я использовала упрощенную модель Воинов из предыдущих лабораторных работ.

В файле `main.py` после объявления переменной приложения я создала набор данных в виде переменной, представляющей временную БД:

```python
temp_bd = [
    {"id": 1, "name": "Воин 1", "level": 10, "profession": "Воин", "skills": ["Удар мечом", "Блокировка"]},
    {"id": 2, "name": "Воин 2", "level": 15, "profession": "Маг", "skills": ["Огненный шар", "Ледяной дождь"]},
    {"id": 3, "name": "Воин 3", "level": 20, "profession": "Лучник", "skills": ["Стрела молнии", "Точный выстрел"]}
]
```
Создание API-эндпоинтов
Для реализации CRUD-API в моем приложении я использовала специальные методы, описывающие HTTP-запросы внутри веб-приложения. Все эти методы вызываются через переменную, представляющую класс FastAPI. Их параметры и возможные виды запросов представлены в документации FastAPI.

Ниже приведен список методов, необходимых для реализации простого CRUD-интерфейса. Все запросы можно выполнить по адресу 127.0.0.1:8000/docs.

Запрос всех воинов:
```python
@app.get("/warriors_list")
def warriors_list():
    return temp_bd
```
Запрос конкретного воина:
```python
@app.get("/warrior/{warrior_id}")
def warriors_list(warrior_id: int):
    return [warrior for warrior in temp_bd if warrior.get("id") == warrior_id]
```
Добавление воина:
```python
@app.post("/warrior")
def warriors_list(warrior: dict):
    temp_bd.append(warrior)
    return {"status": 200, "data": warrior}
```
Удаление воина:
```python
@app.delete("/warrior/delete{warrior_id}")
def warrior_delete(warrior_id: int):
    for i, warrior in enumerate(temp_bd):
        if warrior.get("id") == warrior_id:
            temp_bd.pop(i)
            break
    return {"status": 201, "message": "deleted"}
```
Редактирование воина:
```python

@app.put("/warrior{warrior_id}")
def warrior_update(warrior_id: int, warrior: dict):
    for i, war in enumerate(temp_bd):
        if war.get("id") == warrior_id:
            temp_bd[i] = warrior
    return temp_bd
```

Такая реализация имеет некоторые проблемные моменты, такие как возможность передачи данных любого формата и отсутствие возможности идентификации объектов. Эти проблемы решаются при использовании Pydantic для аннотирования и сериализации объектов, о чем будет рассказано далее.